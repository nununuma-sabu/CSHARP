# Day 1: 型システムとメモリ管理の基礎

## 目標
値型と参照型の違いを理解し、ガベージコレクションの挙動を観測する。

## 学習項目

### 1. CTS (Common Type System) の理解
- `int` vs `System.Int32`

### 2. メモリ配置の違い
- 値型 (`struct`, `enum`) と参照型 (`class`) のメモリ配置の違い

![PointStruct 配列のメモリレイアウト](img/図1%20PointStruct%20配列のメモリレイアウト.png)
*図1: PointStruct (値型) 配列のメモリレイアウト - データが連続して配置される*

![PointClass 配列のメモリレイアウト](img/図2%20PointClass%20配列のメモリレイアウト.png)
*図2: PointClass (参照型) 配列のメモリレイアウト - 参照を介してヒープ上のオブジェクトにアクセス*

### 3. ボックス化のコスト
- ボックス化 (Boxing) とボックス化解除 (Unboxing) のコスト

![ボクシングとジェネリク��の比較](img/図3%20ボクシング（上）とジェネリクス（下）の比較.png)
*図3: ボクシング（上）とジェネリクス（下）の比較 - ジェネリクスはヒープ割り当てを回避*

### 4. 型推論
- `var`による型推論（C++の`auto`との比較）

## 実装課題:  メモリトラフィック監視アプリケーション
コンソールアプリケーションを作成し、以下の実験を行うコードを実装せよ。

### 課題1: Struct vs Class
- `int X, Y;`を持つ`struct PointS`と`class PointC`を定義する
- それぞれ100万個の配列を作成し、初期化にかかる時間とメモリ使用量（`GC.GetTotalMemory`）を測定する

### 課題2: Boxingの検出
- `object`型を引数に取るメソッドを定義し、そこに`int`（値型）を渡す処理をループで100万回実行する
- ジェネリックメソッドを使用した場合と比較する

### 課題3: GCの観測
- `GC.Collect()`を明示的に呼び出し、オブジェクトの世代（Generation 0, 1, 2）がどのように推移するかを`GC.GetGeneration()`を用いてコンソールに出力する

![GC世代昇格のシーケンス図](img/図4%20GC世代昇格のシーケンス図.png)
*図4: GC世代昇格のシーケンス図 - オブジェクトがGen0からGen2へ昇格する過程*

## 得られる知見
C#においては、データ構造を`struct`にするか`class`にするかの選択が、GCの負荷に直結することを理解する。C++のように「すべてをオブジェクトとして扱う」のではなく、用途に応じた型選択が重要である。